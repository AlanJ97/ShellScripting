
#BASIC SINTAX
awk [OPTIONS] FILE

#PRINT CONTENT OF A FILE
awk 'BEGIN {} {print}' marks.txt

#PRINT CONTENT OF A FILE WITH HEADERS
awk 'BEGIN{printf "Sr No\tName\tSub\tMarks\n"} {print}' marks.txt

#BASIC SINTAX OF HOW TO USE A FILE WITH INSTRUCTIONS AS THE PURE INSTRUCTONS ON THE COMMAND LINE
awk [options] -f file ....

#READ CONTENT OF A FILE WITH A FILE AS INSTRUCTION
awk -f command.awk marks.txt

---------------------------
#AWK STANDARD OPTIONS

#-v option -> It assigns values to a variable before the program execution
awk -v name=Jerry 'BEGIN{printf "Name = %s\n", name}'

#--dump-variables[=file] option -> It prints a sorted list of global variables and their final 
#values to file. The default file is awkvars.out.
awk --dump-variables ''
cat awkvars.out 

#--help option -> This option prints the help message on standard output.
awk --help

#--lint[=fatal] option ->This option enables checking of non-portable or dubious constructs. 
#When an argument fatal is provided, it treats warning messages as errors. 

#--posix option -> This option turns on strict POSIX compatibility, in which all 
#common and gawk-specific extensions are disabled.
SIN EJEMPLO

#--profile[=file] option -> This option generates a pretty-printed version of the program 
#in file. Default file is awkprof.out. 
awk --profile 'BEGIN{printf"---|Header|--\n"} {print} END{printf"---|Footer|---\n"}' marks.txt > /dev/null 

#--traditional option -> This option disables all gawk-specific extensions.
SIN EJEMPLO

#--version option -> This option displays the version information of the AWK program.
awk --version

-------------------

#PRINTING ONE COLUMN OR FIELD
#"\t" -> this alignsthe text
awk '{print $3 "\t" $4}' marks.txt

#PRINTING ALL LINES
#/a/ -> this is like an if statement, if the thing that we're looking for exists
# it gets the searched thing, otherwise, it shows everything
awk '/a/ {print $0}' marks.txt
awk '/a/' marks.txt -> as this sentence has no cryteria to look for, it prints everything

#PRINTING COLUMNS IN ANY ORDER
awk '/a/ {print $4 "\t" $3}' marks.txt

#CONTING AND PRINTING MATCHED PATTERN
awk '/a/{++cnt} END {print "Count = ", cnt}' marks.txt

#PRINTING LINES THAT CONTAIN MORE THAN 18 CHARACTERS
awk 'length($0) > 18' marks.txt

----------------
#standard awk variables
#ARGC -> It implies the number of arguments provided at the command line.
#It shows arguments because, it is also ounting 'awk' at the beginning
awk 'BEGIN {print "Arguments =", ARGC}' One Two Three Four

#CONVFMT
#It represents the conversion format for numbers. Its default value is %.6g.
awk 'BEGIN { print "Conversion Format =", CONVFMT }'

#ENVIRON
#It is an associative array of environment variables.
awk 'BEGIN { print ENVIRON["USER"] }'

#FILENAME
#It represents the current file name.
awk 'END {print FILENAME}' marks.txt

#FS
#It represents the (input) field separator and its default value is space.
#You can also change this by using -F command line option.
awk 'BEGIN {print "FS = " FS}' | cat -vte

#NF
#It represents the number of fields in the current record. For instance,
#the following example prints only those lines that contain more than two fields.


#NR
#It represents the number of the current record. For instance, 
#the following example prints the record if the current record number is less than three.
echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NR < 3'

#FNR
#It is similar to NR, but relative to the current file. It is useful when AWK is operating
#on multiple files. Value of FNR resets with new file.
SIN EJEMPLO

#OFMT
#It represents the output format number and its default value is %.6g.
awk 'BEGIN {print "OFMT = " OFMT}'

#OFS
#It represents the output field separator and its default value is space.
awk 'BEGIN {print "OFS = " OFS}' | cat -vte

#ORS
#It represents the output record separator and its default value is newline.
awk 'BEGIN {print "ORS = " ORS}' | cat -vte

#RLENGTH
#It represents the length of the string matched by match function. 
#AWK's match function searches for a given string in the input-string.
awk 'BEGIN { if (match("One Two Three", "re")) { print RLENGTH } }'

#RS
#It represents (input) record separator and its default value is newline.
awk 'BEGIN {print "RS = " RS}' | cat -vte

#RSTART
#It represents the first position in the string matched by match function.
awk 'BEGIN { if (match("One Two Three", "Thre")) { print RSTART } }'

#SUBSEP
#It represents the separator character for array subscripts and its default value is \034.
awk 'BEGIN { print "SUBSEP = " SUBSEP }' | cat -vte

#$0
#It represents the entire input record.
awk '{print $0}' marks.txt

#$n
#It represents the nth field in the current record where the fields are separated by FS.
awk '{print $3 "\t" $4}' marks.txt

---------------------

GNU AWK Specific Variables
---------------------
#ARGIND
#It represents the index in ARGV of the current file being processed.
awk '{ 
   print "ARGIND   = ", ARGIND; print "Filename = ", ARGV[ARGIND] 
}' junk1 junk2 junk3

#BINMODE
#It is used to specify binary mode for all file I/O on non-POSIX systems. 
#Numeric values of 1, 2, or 3 specify that input files, output files, or all files,
#respectively, should use binary I/O. String values of r or w specify that input 
#files or output files, respectively, should use binary I/O. String values of rw or 
#wr specify that all files should use binary I/O.
SIN EJEMPLO

#ERRNO
#A string indicates an error when a redirection fails for getline or if close call fails.
awk 'BEGIN { ret = getline < "junk.txt"; if (ret == -1) print "Error:", ERRNO }'

#FIELDWIDTHS
#A space separated list of field widths variable is set, GAWK parses the input into fields of 
#fixed width, instead of using the value of the FS variable as the field separator.
awk 'BEGIN{IGNORECASE = 1} /amit/' marks.txt

#FIELDWIDTHS
#A space separated list of field widths variable is set, GAWK parses the input into fields of 
#fixed width, instead of using the value of the FS variable as the field separator.
SIN EJEMPLO

#IGNORECASE
#When this variable is set, GAWK becomes case-insensitive. 
awk 'BEGIN{IGNORECASE = 1} /amit/' marks.txt

#LINT
#It provides dynamic control of the --lint option from the GAWK program. When this variable 
#is set, GAWK prints lint warnings. When assigned the string value fatal, lint warnings
#become fatal errors, exactly like --lint=fat
awk 'BEGIN {LINT = 1; a}'

#PROCINFO
#This is an associative array containing information about the process, 
#such as real and effective UID numbers, process ID number, and so on.
awk 'BEGIN { print PROCINFO["pid"] }'

#TEXTDOMAIN
#It represents the text domain of the AWK program. It is used to find the 
#localized translations for the program's strings.
awk 'BEGIN { print TEXTDOMAIN }'

---------------

Arithmetic Operators
----------------

#Addition
#It is represented by plus (+) symbol which adds two or more numbers.
awk 'BEGIN { a = 50; b = 20; print "(a + b) = ", (a + b) }'

#Subtraction
#It is represented by minus (-) symbol which subtracts two or more numbers.
awk 'BEGIN { a = 50; b = 20; print "(a - b) = ", (a - b) }'

#Multiplication
#It is represented by asterisk (*) symbol which multiplies two or more numbers. 
awk 'BEGIN { a = 50; b = 20; print "(a * b) = ", (a * b) }'

#Division
#It is represented by slash (/) symbol which divides two or more numbers. 
awk 'BEGIN { a = 50; b = 20; print "(a / b) = ", (a / b) }'

#Modulus
#It is represented by percent (%) symbol which finds the Modulus division of 
#two or more numbers. 

----------------

IMCREMENT AND DECREMENT 
------------------

#Pre-Increment
#It is represented by ++. It increments the value of an operand by 1. 
#This operator first increments the value of the operand, 
#then returns the incremented value. For instance, in the following example,
#this operator sets the value of both the operands, a and b, to 11.
awk 'BEGIN { a = 10; b = ++a; printf "a = %d, b = %d\n", a, b }'

#Pre-Decrement
#It is represented by --. It decrements the value of an operand by 1. 
#This operator first decrements the value of the operand,
#then returns the decremented value. For instance, in the following example,3
#this operator sets the value of both the operands, a and b, to 9.
awk 'BEGIN { a = 10; b = --a; printf "a = %d, b = %d\n", a, b }'

#Post-Increment
#It is represented by ++. It increments the value of an operand by 1.
#This operator first returns the value of the operand, then it increments 
#its value. For instance, the following code sets the value of operand a to 11 and b to 10.
awk 'BEGIN { a = 10; b = a++; printf "a = %d, b = %d\n", a, b }'

#Post-Decrement
#It is represented by --. It decrements the value of an operand by 1. 
#This operator first returns the value of the operand, 
#then it decrements its value. For instance, the following 
#code sets the value of the operand a to 9 and b to 10.
awk 'BEGIN { a = 10; b = a--; printf "a = %d, b = %d\n", a, b }'

------------------

Assignment Operators

#Simple Assignment
#It is represented by =.
awk 'BEGIN { name = "Jerry"; print "My name is", name }'

#Shorthand Addition
#It is represented by +=.
awk 'BEGIN { cnt = 10; cnt += 10; print "Counter =", cnt }'

#Shorthand Subtraction
#It is represented by -=
awk 'BEGIN { cnt = 100; cnt -= 10; print "Counter =", cnt }'

#Shorthand Multiplication
#It is represented by *=.
awk 'BEGIN { cnt = 10; cnt *= 10; print "Counter =", cnt }'

#Shorthand Division
#It is represented by /=. 
awk 'BEGIN { cnt = 100; cnt /= 5; print "Counter =", cnt }'

#Shorthand Modulo
#It is represented by %=.
awk 'BEGIN { cnt = 100; cnt %= 8; print "Counter =", cnt }'

#Shorthand Exponential
#It is represented by ^=.
awk 'BEGIN { cnt = 2; cnt ^= 4; print "Counter =", cnt }'


#Shorthand Exponential
#It is represented by **=.
awk 'BEGIN { cnt = 2; cnt **= 4; print "Counter =", cnt }'

---------------------

RELATIONAL OPERATORS
----------------------
#Equal to
#It is represented by ==. It returns true if both operands are equal, 
#otherwise it returns false.
awk 'BEGIN { a = 10; b = 10; if (a == b) print "a == b" }'

#Not Equal to
#It is represented by !=. It returns true if both operands are unequal,
#otherwise it returns false.
awk 'BEGIN { a = 10; b = 20; if (a != b) print "a != b" }'

#Less Than
#It is represented by <. It returns true if the left-side operand is less 
#than the right-side operand; otherwise it returns false.
awk 'BEGIN { a = 10; b = 20; if (a < b) print "a  < b" }'

#Less Than or Equal to
#It is represented by <=. It returns true if the left-side operand is 
#less than or equal to the right-side operand; otherwise it returns false.
awk 'BEGIN { a = 10; b = 10; if (a <= b) print "a <= b" }'

#Greater Than
#It is represented by >. It returns true if the left-side operand is greater
#than the right-side operand, otherwise it returns false.
awk 'BEGIN { a = 10; b = 20; if (b > a ) print "b > a" }'

#Greater Than or Equal to
#It is represented by >=. It returns true if the left-side operand is 
#greater than or equal to the right-side operand; otherwise it returns false.
awk 'BEGIN { a = 100; b = 20; if (a > b) print "a  > b" }'
------------

LOGICAL OPERATORS
--------------

#Logical AND
#It is represented by &&. Its syntax is as follows 
#expr1 && expr2
#It evaluates to true if both expr1 and expr2 evaluate to true; 
#otherwise it returns false. expr2 is evaluated if and only if expr1 evaluates to true. 
 awk 'BEGIN {
   num = 5; if (num >= 0 && num <= 7) printf "%d is in octal format\n", num 
}'

#Logical OR
#It is represented by ||. The syntax of Logical OR is
#expr1 || expr2
#It evaluates to true if either expr1 or expr2 evaluates to true; 
#otherwise it returns false. expr2 is evaluated if and only if expr1 evaluates to false. 
#The following example demonstrates this −
awk 'BEGIN {
   ch = "\n"; if (ch == " " || ch == "\t" || ch == "\n") 
   print "Current character is whitespace." 
}'

#Logical NOT
#It is represented by exclamation mark (!). The following example demonstrates this
#! expr1
#It returns the logical compliment of expr1. If expr1 evaluates to true, it returns 0;
#otherwise it returns 1. For instance, the following example checks 
#whether a string is empty or not.
awk 'BEGIN { name = ""; if (! length(name)) print "name is empty string." }'

----------------

TERNARY OPERATORS 
---------------------
#We can easily implement a condition expression using ternary operator.
#The following example demonstrates this
#condition expression ? statement1 : statement2
#When the condition expression returns true, statement1 gets executed;
#otherwise statement2 is executed.
awk 'BEGIN { a = 10; b = 20; (a > b) ? max = a : max = b; print "Max =", max}'

------------

UNARY OPERATORS
---------------
#Unary Plus
#It is represented by +. It multiplies a single operand by +1.
awk 'BEGIN { a = -10; a = +a; print "a =", a }'

#Unary Minus
#It is represented by -. It multiplies a single operand by -1.
awk 'BEGIN { a = -10; a = -a; print "a =", a }'
-------------------

EXPONENTIAL OPERATORS
-------------------
#Exponential Format 1
#It is an exponential operator that raises the value of an operand. 
#For instance, the following example raises the value of 10 by 2.
awk 'BEGIN { a = 10; a = a ^ 2; print "a =", a }'

#Exponential Format 2
#It is an exponential operator that raises the value of an operand. 
#For instance, the following example raises the value of 10 by 2.
awk 'BEGIN { a = 10; a = a**2; print "a =", a }'

--------------------------

#STRING CONCANETATION OPERATOR
#Space is a string concatenation operator that merges two strings. 
#The following example demonstrates this −
awk 'BEGIN { str1 = "Hello, "; str2 = "World"; str3 = str1 str2; print str3 }'

---------------------------------

ARRAY MEMBERSHIP OPERATOR
-------------------
#It is represented by in. It is used while accessing array elements.
#The following example prints array elements using this operator.
awk 'BEGIN { 
   arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf "arr[%d] = %d\n", i, arr[i]
}'

--------------------

REGULAR EXPRESSION OPERATOR
----------------------------
#Match
#It is represented as ~. It looks for a field that contains the match string. For instance,
#the following example prints the lines that contain the pattern 9.
awk '$0 ~ 9' marks.txt

#Not Match
#It is represented as !~. It looks for a field that does not contain the match string. 
#For instance, the following example prints the lines that do not contain the pattern 9.
awk '$0 !~ 9' marks.txt

#Dot
#It matches any single character except the end of line character.
#For instance, the following example matches fin, fun, fan etc.
echo -e "cat\nbat\nfun\nfin\nfan" | awk '/f.n/'

#Start of line
#It matches the start of line. 
#For instance, the following example prints all the lines that start with pattern The.
echo -e "This\nThat\nThere\nTheir\nthese" | awk '/^The/'

#End of line
#It matches the end of line. For instance, the following example prints the lines 
#that end with the letter n.
echo -e "knife\nknow\nfun\nfin\nfan\nnine" | awk '/n$/'

#Match character set
#It is used to match only one out of several characters.
#For instance, the following example matches pattern Call and Tall but not Ball.
echo -e "Call\nTall\nBall" | awk '/[CT]all/'

#Exclusive set
#In exclusive set, the carat negates the set of characters in the square brackets. 
#For instance, the following example prints only Ball.
echo -e "Call\nTall\nBall" | awk '/[^CT]all/'

#Alteration
#A vertical bar allows regular expressions to be logically ORed. 
#For instance, the following example prints Ball and Call.
echo -e "Call\nTall\nBall\nSmall\nShall" | awk '/Call|Ball/'


#Zero or One Occurrence
#It matches zero or one occurrence of the preceding character. 
#For instance, the following example matches Colour as well as Color.
#We have made u as an optional character by using ?.
echo -e "Colour\nColor" | awk '/Colou?r/'

#Zero or More Occurrence
#It matches zero or more occurrences of the preceding character. 
#For instance, the following example matches ca, cat, catt, and so on.
echo -e "ca\ncat\ncatt" | awk '/cat*/'

#One or More Occurrence
#It matches one or more occurrence of the preceding character. 
#For instance below example matches one or more occurrences of the 2.
echo -e "111\n22\n123\n234\n456\n222"  | awk '/2+/'

#Grouping
#Parentheses () are used for grouping and the character | is used for alternatives. 
#For instance, the following regular expression matches the lines containing 
#either Apple Juice or Apple Cake.