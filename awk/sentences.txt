
#BASIC SINTAX
awk [OPTIONS] FILE

#PRINT CONTENT OF A FILE
awk 'BEGIN {} {print}' marks.txt

#PRINT CONTENT OF A FILE WITH HEADERS
awk 'BEGIN{printf "Sr No\tName\tSub\tMarks\n"} {print}' marks.txt

#BASIC SINTAX OF HOW TO USE A FILE WITH INSTRUCTIONS AS THE PURE INSTRUCTONS ON THE COMMAND LINE
awk [options] -f file ....

#READ CONTENT OF A FILE WITH A FILE AS INSTRUCTION
awk -f command.awk marks.txt

---------------------------
#AWK STANDARD OPTIONS

#-v option -> It assigns values to a variable before the program execution
awk -v name=Jerry 'BEGIN{printf "Name = %s\n", name}'

#--dump-variables[=file] option -> It prints a sorted list of global variables and their final 
#values to file. The default file is awkvars.out.
awk --dump-variables ''
cat awkvars.out 

#--help option -> This option prints the help message on standard output.
awk --help

#--lint[=fatal] option ->This option enables checking of non-portable or dubious constructs. 
#When an argument fatal is provided, it treats warning messages as errors. 

#--posix option -> This option turns on strict POSIX compatibility, in which all 
#common and gawk-specific extensions are disabled.
SIN EJEMPLO

#--profile[=file] option -> This option generates a pretty-printed version of the program 
#in file. Default file is awkprof.out. 
awk --profile 'BEGIN{printf"---|Header|--\n"} {print} END{printf"---|Footer|---\n"}' marks.txt > /dev/null 

#--traditional option -> This option disables all gawk-specific extensions.
SIN EJEMPLO

#--version option -> This option displays the version information of the AWK program.
awk --version

-------------------

#PRINTING ONE COLUMN OR FIELD
#"\t" -> this alignsthe text
awk '{print $3 "\t" $4}' marks.txt

#PRINTING ALL LINES
#/a/ -> this is like an if statement, if the thing that we're looking for exists
# it gets the searched thing, otherwise, it shows everything
awk '/a/ {print $0}' marks.txt
awk '/a/' marks.txt -> as this sentence has no cryteria to look for, it prints everything

#PRINTING COLUMNS IN ANY ORDER
awk '/a/ {print $4 "\t" $3}' marks.txt

#CONTING AND PRINTING MATCHED PATTERN
awk '/a/{++cnt} END {print "Count = ", cnt}' marks.txt

#PRINTING LINES THAT CONTAIN MORE THAN 18 CHARACTERS
awk 'length($0) > 18' marks.txt

----------------
#standard awk variables
#ARGC -> It implies the number of arguments provided at the command line.
#It shows arguments because, it is also ounting 'awk' at the beginning
awk 'BEGIN {print "Arguments =", ARGC}' One Two Three Four

#CONVFMT
#It represents the conversion format for numbers. Its default value is %.6g.
awk 'BEGIN { print "Conversion Format =", CONVFMT }'

#ENVIRON
#It is an associative array of environment variables.
awk 'BEGIN { print ENVIRON["USER"] }'

#FILENAME
#It represents the current file name.
awk 'END {print FILENAME}' marks.txt

#FS
#It represents the (input) field separator and its default value is space.
#You can also change this by using -F command line option.
awk 'BEGIN {print "FS = " FS}' | cat -vte

#NF
#It represents the number of fields in the current record. For instance,
#the following example prints only those lines that contain more than two fields.


#NR
#It represents the number of the current record. For instance, 
#the following example prints the record if the current record number is less than three.
echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NR < 3'

#FNR
#It is similar to NR, but relative to the current file. It is useful when AWK is operating
#on multiple files. Value of FNR resets with new file.
SIN EJEMPLO

#OFMT
#It represents the output format number and its default value is %.6g.
awk 'BEGIN {print "OFMT = " OFMT}'

#OFS
#It represents the output field separator and its default value is space.
awk 'BEGIN {print "OFS = " OFS}' | cat -vte

#ORS
#It represents the output record separator and its default value is newline.
awk 'BEGIN {print "ORS = " ORS}' | cat -vte

#RLENGTH
#It represents the length of the string matched by match function. 
#AWK's match function searches for a given string in the input-string.
awk 'BEGIN { if (match("One Two Three", "re")) { print RLENGTH } }'

#RS
#It represents (input) record separator and its default value is newline.
awk 'BEGIN {print "RS = " RS}' | cat -vte

#RSTART
#It represents the first position in the string matched by match function.
awk 'BEGIN { if (match("One Two Three", "Thre")) { print RSTART } }'

#SUBSEP
#It represents the separator character for array subscripts and its default value is \034.
awk 'BEGIN { print "SUBSEP = " SUBSEP }' | cat -vte

#$0
#It represents the entire input record.
awk '{print $0}' marks.txt

#$n
#It represents the nth field in the current record where the fields are separated by FS.
awk '{print $3 "\t" $4}' marks.txt

---------------------

GNU AWK Specific Variables
---------------------
#ARGIND
#It represents the index in ARGV of the current file being processed.
awk '{ 
   print "ARGIND   = ", ARGIND; print "Filename = ", ARGV[ARGIND] 
}' junk1 junk2 junk3

#BINMODE
#It is used to specify binary mode for all file I/O on non-POSIX systems. 
#Numeric values of 1, 2, or 3 specify that input files, output files, or all files,
#respectively, should use binary I/O. String values of r or w specify that input 
#files or output files, respectively, should use binary I/O. String values of rw or 
#wr specify that all files should use binary I/O.
SIN EJEMPLO

#ERRNO
#A string indicates an error when a redirection fails for getline or if close call fails.
awk 'BEGIN { ret = getline < "junk.txt"; if (ret == -1) print "Error:", ERRNO }'

#FIELDWIDTHS
#A space separated list of field widths variable is set, GAWK parses the input into fields of 
#fixed width, instead of using the value of the FS variable as the field separator.
awk 'BEGIN{IGNORECASE = 1} /amit/' marks.txt

#FIELDWIDTHS
#A space separated list of field widths variable is set, GAWK parses the input into fields of 
#fixed width, instead of using the value of the FS variable as the field separator.
SIN EJEMPLO

#IGNORECASE
#When this variable is set, GAWK becomes case-insensitive. 
awk 'BEGIN{IGNORECASE = 1} /amit/' marks.txt

#LINT
#It provides dynamic control of the --lint option from the GAWK program. When this variable 
#is set, GAWK prints lint warnings. When assigned the string value fatal, lint warnings
#become fatal errors, exactly like --lint=fat
awk 'BEGIN {LINT = 1; a}'

#PROCINFO
#This is an associative array containing information about the process, 
#such as real and effective UID numbers, process ID number, and so on.
awk 'BEGIN { print PROCINFO["pid"] }'

#TEXTDOMAIN
#It represents the text domain of the AWK program. It is used to find the 
#localized translations for the program's strings.